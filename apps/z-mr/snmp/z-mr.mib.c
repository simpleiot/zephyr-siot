/*
Generated by LwipMibCompiler
*/

#include "lwip/apps/snmp_opts.h"
#if LWIP_SNMP

#include "z-mr.mib.h"
#include "lwip/apps/snmp.h"
#include "lwip/apps/snmp_core.h"
#include "lwip/apps/snmp_scalar.h"
#include "lwip/apps/snmp_table.h"

extern s32_t ask_ats_mode();

/* --- ats2Measure 62530.2.2 ----------------------------------------------------- */
static s16_t ats2input_scalars_get_value(const struct snmp_scalar_array_node_def *node,
					 void *value);
static const struct snmp_scalar_array_node_def ats2input_scalars_nodes[] = {
	{1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* ats2InputDephasing */
};
static const struct snmp_scalar_array_node ats2input_scalars = SNMP_SCALAR_CREATE_ARRAY_NODE(
	1, ats2input_scalars_nodes, ats2input_scalars_get_value, NULL, NULL);

static snmp_err_t ats2inputtable_get_instance(const u32_t *column, const u32_t *row_oid,
					      u8_t row_oid_len,
					      struct snmp_node_instance *cell_instance);
static snmp_err_t ats2inputtable_get_next_instance(const u32_t *column, struct snmp_obj_id *row_oid,
						   struct snmp_node_instance *cell_instance);
static s16_t ats2inputtable_get_value(struct snmp_node_instance *cell_instance, void *value);
static const struct snmp_table_col_def ats2inputtable_columns[] = {
	{1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* ats2InputIndex */
	{2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* ats2InputVoltage */
	{3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* ats2InputFrequency */
};
static const struct snmp_table_node ats2inputtable =
	SNMP_TABLE_CREATE(2, ats2inputtable_columns, ats2inputtable_get_instance,
			  ats2inputtable_get_next_instance, ats2inputtable_get_value, NULL, NULL);

static s16_t ats2output_scalars_get_value(const struct snmp_scalar_array_node_def *node,
					  void *value);
static const struct snmp_scalar_array_node_def ats2output_scalars_nodes[] = {
	{1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* ats2OutputVoltage */
	{2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* ats2OutputCurrent */
};
static const struct snmp_scalar_array_node ats2output_scalars = SNMP_SCALAR_CREATE_ARRAY_NODE(
	3, ats2output_scalars_nodes, ats2output_scalars_get_value, NULL, NULL);

static s16_t ats2OperationMode_get_value(struct snmp_node_instance *instance, void *value);
static const struct snmp_scalar_node ats2operationmode_scalar =
	SNMP_SCALAR_CREATE_NODE_READONLY(4, SNMP_ASN1_TYPE_INTEGER, ats2OperationMode_get_value);

static const struct snmp_node *const ats2measure_subnodes[] = {
	&ats2input_scalars.node.node,       // 1
	&ats2inputtable.node.node,          // 2
	&ats2output_scalars.node.node,      // 3
	&ats2operationmode_scalar.node.node // 4 (1.3.6.1.4.1.62530.2.4.1.1.0)
};
// 62530.2.2.[1-4]
static const struct snmp_tree_node ats2measure_treenode =
	SNMP_CREATE_TREE_NODE(2, ats2measure_subnodes); // iod 2

/* --- ats2Status 62530.2.3 ----------------------------------------------------- */
static s16_t ats2inputstatus_scalars_get_value(const struct snmp_scalar_array_node_def *node,
					       void *value);
static const struct snmp_scalar_array_node_def ats2inputstatus_scalars_nodes[] = {
	{1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* ats2InputStatusDephasing */
};
static const struct snmp_scalar_array_node ats2inputstatus_scalars = SNMP_SCALAR_CREATE_ARRAY_NODE(
	1, ats2inputstatus_scalars_nodes, ats2inputstatus_scalars_get_value, NULL, NULL);

static snmp_err_t ats2inputstatustable_get_instance(const u32_t *column, const u32_t *row_oid,
						    u8_t row_oid_len,
						    struct snmp_node_instance *cell_instance);
static snmp_err_t ats2inputstatustable_get_next_instance(const u32_t *column,
							 struct snmp_obj_id *row_oid,
							 struct snmp_node_instance *cell_instance);
static s16_t ats2inputstatustable_get_value(struct snmp_node_instance *cell_instance, void *value);
static const struct snmp_table_col_def ats2inputstatustable_columns[] = {
	{1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* ats2InputStatusIndex */
	{2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* ats2InputStatusFrequency */
	{3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* ats2InputStatusGood */
	{4, SNMP_ASN1_TYPE_INTEGER,
	 SNMP_NODE_INSTANCE_READ_ONLY}, /* ats2InputStatusInternalFailure */
	{5, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* ats2InputStatusVoltage */
	{6, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* ats2InputStatusUsed */
};
static const struct snmp_table_node ats2inputstatustable = SNMP_TABLE_CREATE(
	2, ats2inputstatustable_columns, ats2inputstatustable_get_instance,
	ats2inputstatustable_get_next_instance, ats2inputstatustable_get_value, NULL, NULL);

static s16_t ats2outputstatus_scalars_get_value(const struct snmp_scalar_array_node_def *node,
						void *value);
static const struct snmp_scalar_array_node_def ats2outputstatus_scalars_nodes[] = {
	{1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* ats2StatusInternalFailure */
	{2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* ats2StatusOutput */
	{3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* ats2StatusOverload */
	{4, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* ats2StatusOverTemperature */
	{5, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* ats2StatusShortCircuit */
	{6, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* ats2StatusCommunicationLost */
	{7, SNMP_ASN1_TYPE_INTEGER,
	 SNMP_NODE_INSTANCE_READ_ONLY}, /* ats2StatusConfigurationFailure */
};
static const struct snmp_scalar_array_node ats2outputstatus_scalars = SNMP_SCALAR_CREATE_ARRAY_NODE(
	3, ats2outputstatus_scalars_nodes, ats2outputstatus_scalars_get_value, NULL, NULL);

static const struct snmp_node *const ats2status_subnodes[] = {&ats2inputstatus_scalars.node.node,
							      &ats2inputstatustable.node.node,
							      &ats2outputstatus_scalars.node.node};
static const struct snmp_tree_node ats2status_treenode =
	SNMP_CREATE_TREE_NODE(3, ats2status_subnodes);

/* --- ats2Config 62530.2.4 ----------------------------------------------------- */
static s16_t ats2config_treenode_get_value(struct snmp_node_instance *instance, void *value);
static snmp_err_t ats2config_treenode_set_test(struct snmp_node_instance *instance, u16_t len,
					       void *value);
static snmp_err_t ats2config_treenode_set_value(struct snmp_node_instance *instance, u16_t len,
						void *value);
static s16_t ats2configtime_scalars_get_value(const struct snmp_scalar_array_node_def *node,
					      void *value);
static snmp_err_t ats2configtime_scalars_set_test(const struct snmp_scalar_array_node_def *node,
						  u16_t len, void *value);
static snmp_err_t ats2configtime_scalars_set_value(const struct snmp_scalar_array_node_def *node,
						   u16_t len, void *value);
static const struct snmp_scalar_array_node_def ats2configtime_scalars_nodes[] = {
	{1, SNMP_ASN1_TYPE_COUNTER, SNMP_NODE_INSTANCE_READ_WRITE}, /* ats2ConfigTimeRTC */
};
static const struct snmp_scalar_array_node ats2configtime_scalars = SNMP_SCALAR_CREATE_ARRAY_NODE(
	1, ats2configtime_scalars_nodes, ats2configtime_scalars_get_value,
	ats2configtime_scalars_set_test, ats2configtime_scalars_set_value);

static const struct snmp_scalar_node ats2configinputvoltagerating_scalar =
	SNMP_SCALAR_CREATE_NODE_READONLY(2, SNMP_ASN1_TYPE_INTEGER, ats2config_treenode_get_value);

static const struct snmp_scalar_node ats2configinputfrequencyrating_scalar =
	SNMP_SCALAR_CREATE_NODE_READONLY(3, SNMP_ASN1_TYPE_INTEGER, ats2config_treenode_get_value);

static const struct snmp_scalar_node ats2configoutputvoltage_scalar = SNMP_SCALAR_CREATE_NODE(
	4, SNMP_NODE_INSTANCE_READ_WRITE, SNMP_ASN1_TYPE_INTEGER, ats2config_treenode_get_value,
	ats2config_treenode_set_test, ats2config_treenode_set_value);

static const struct snmp_scalar_node ats2configpreferred_scalar = SNMP_SCALAR_CREATE_NODE(
	5, SNMP_NODE_INSTANCE_READ_WRITE, SNMP_ASN1_TYPE_INTEGER, ats2config_treenode_get_value,
	ats2config_treenode_set_test, ats2config_treenode_set_value);

static const struct snmp_scalar_node ats2configsensitivity_scalar = SNMP_SCALAR_CREATE_NODE(
	6, SNMP_NODE_INSTANCE_READ_WRITE, SNMP_ASN1_TYPE_INTEGER, ats2config_treenode_get_value,
	ats2config_treenode_set_test, ats2config_treenode_set_value);

static const struct snmp_scalar_node ats2configtransfermode_scalar = SNMP_SCALAR_CREATE_NODE(
	7, SNMP_NODE_INSTANCE_READ_WRITE, SNMP_ASN1_TYPE_INTEGER, ats2config_treenode_get_value,
	ats2config_treenode_set_test, ats2config_treenode_set_value);

static const struct snmp_scalar_node ats2configtransfertest_scalar =
	SNMP_SCALAR_CREATE_NODE_READONLY(8, SNMP_ASN1_TYPE_INTEGER, ats2config_treenode_get_value);

static const struct snmp_scalar_node ats2configbrownoutlow_scalar =
	SNMP_SCALAR_CREATE_NODE_READONLY(9, SNMP_ASN1_TYPE_INTEGER, ats2config_treenode_get_value);

static const struct snmp_scalar_node ats2configbrownoutlowderated_scalar =
	SNMP_SCALAR_CREATE_NODE_READONLY(10, SNMP_ASN1_TYPE_INTEGER, ats2config_treenode_get_value);

static const struct snmp_scalar_node ats2configbrownouthigh_scalar =
	SNMP_SCALAR_CREATE_NODE_READONLY(11, SNMP_ASN1_TYPE_INTEGER, ats2config_treenode_get_value);

static const struct snmp_scalar_node ats2confighysteresisvoltage_scalar =
	SNMP_SCALAR_CREATE_NODE_READONLY(12, SNMP_ASN1_TYPE_INTEGER, ats2config_treenode_get_value);

static const struct snmp_node *const ats2config_subnodes[] = {
	&ats2configtime_scalars.node.node,
	&ats2configinputvoltagerating_scalar.node.node,
	&ats2configinputfrequencyrating_scalar.node.node,
	&ats2configoutputvoltage_scalar.node.node,
	&ats2configpreferred_scalar.node.node,
	&ats2configsensitivity_scalar.node.node,
	&ats2configtransfermode_scalar.node.node,
	&ats2configtransfertest_scalar.node.node,
	&ats2configbrownoutlow_scalar.node.node,
	&ats2configbrownoutlowderated_scalar.node.node,
	&ats2configbrownouthigh_scalar.node.node,
	&ats2confighysteresisvoltage_scalar.node.node};
static const struct snmp_tree_node ats2config_treenode =
	SNMP_CREATE_TREE_NODE(4, ats2config_subnodes);

/* --- ats2Environment 62530.2.5 ----------------------------------------------------- */
static s16_t ats2environment_treenode_get_value(struct snmp_node_instance *instance, void *value);
static snmp_err_t ats2environment_treenode_set_test(struct snmp_node_instance *instance, u16_t len,
						    void *value);
static snmp_err_t ats2environment_treenode_set_value(struct snmp_node_instance *instance, u16_t len,
						     void *value);
static const struct snmp_scalar_node ats2envremotetemp_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(
	1, SNMP_ASN1_TYPE_INTEGER, ats2environment_treenode_get_value);

static const struct snmp_scalar_node ats2envremotehumidity_scalar =
	SNMP_SCALAR_CREATE_NODE_READONLY(2, SNMP_ASN1_TYPE_INTEGER,
					 ats2environment_treenode_get_value);

static const struct snmp_scalar_node ats2envnumcontacts_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(
	3, SNMP_ASN1_TYPE_INTEGER, ats2environment_treenode_get_value);

static snmp_err_t ats2contactsensetable_get_instance(const u32_t *column, const u32_t *row_oid,
						     u8_t row_oid_len,
						     struct snmp_node_instance *cell_instance);
static snmp_err_t ats2contactsensetable_get_next_instance(const u32_t *column,
							  struct snmp_obj_id *row_oid,
							  struct snmp_node_instance *cell_instance);
static s16_t ats2contactsensetable_get_value(struct snmp_node_instance *cell_instance, void *value);
static snmp_err_t ats2contactsensetable_set_test(struct snmp_node_instance *cell_instance,
						 u16_t len, void *value);
static snmp_err_t ats2contactsensetable_set_value(struct snmp_node_instance *cell_instance,
						  u16_t len, void *value);
static const struct snmp_table_col_def ats2contactsensetable_columns[] = {
	{1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY},  /* ats2ContactIndex */
	{2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* ats2ContactType */
	{3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY},  /* ats2ContactState */
};
static const struct snmp_table_node ats2contactsensetable =
	SNMP_TABLE_CREATE(4, ats2contactsensetable_columns, ats2contactsensetable_get_instance,
			  ats2contactsensetable_get_next_instance, ats2contactsensetable_get_value,
			  ats2contactsensetable_set_test, ats2contactsensetable_set_value);

static const struct snmp_scalar_node ats2envremotetemplowerlimit_scalar = SNMP_SCALAR_CREATE_NODE(
	5, SNMP_NODE_INSTANCE_READ_WRITE, SNMP_ASN1_TYPE_INTEGER,
	ats2environment_treenode_get_value, ats2environment_treenode_set_test,
	ats2environment_treenode_set_value);

static const struct snmp_scalar_node ats2envremotetempupperlimit_scalar = SNMP_SCALAR_CREATE_NODE(
	6, SNMP_NODE_INSTANCE_READ_WRITE, SNMP_ASN1_TYPE_INTEGER,
	ats2environment_treenode_get_value, ats2environment_treenode_set_test,
	ats2environment_treenode_set_value);

static const struct snmp_scalar_node ats2envremotehumiditylowerlimit_scalar =
	SNMP_SCALAR_CREATE_NODE(7, SNMP_NODE_INSTANCE_READ_WRITE, SNMP_ASN1_TYPE_INTEGER,
				ats2environment_treenode_get_value,
				ats2environment_treenode_set_test,
				ats2environment_treenode_set_value);

static const struct snmp_scalar_node ats2envremotehumidityupperlimit_scalar =
	SNMP_SCALAR_CREATE_NODE(8, SNMP_NODE_INSTANCE_READ_WRITE, SNMP_ASN1_TYPE_INTEGER,
				ats2environment_treenode_get_value,
				ats2environment_treenode_set_test,
				ats2environment_treenode_set_value);

static const struct snmp_node *const ats2environment_subnodes[] = {
	&ats2envremotetemp_scalar.node.node,
	&ats2envremotehumidity_scalar.node.node,
	&ats2envnumcontacts_scalar.node.node,
	&ats2contactsensetable.node.node,
	&ats2envremotetemplowerlimit_scalar.node.node,
	&ats2envremotetempupperlimit_scalar.node.node,
	&ats2envremotehumiditylowerlimit_scalar.node.node,
	&ats2envremotehumidityupperlimit_scalar.node.node};
static const struct snmp_tree_node ats2environment_treenode =
	SNMP_CREATE_TREE_NODE(5, ats2environment_subnodes);

/* --- mib_ats2  ----------------------------------------------------- */
static const struct snmp_node *const ats2_subnodes[] = {
	&ats2measure_treenode.node, &ats2status_treenode.node, &ats2config_treenode.node,
	&ats2environment_treenode.node};
static const struct snmp_tree_node ats2_root = SNMP_CREATE_TREE_NODE(2, ats2_subnodes);
// static const u32_t ats2_base_oid[] = {62530,2};
static const u32_t ats2_base_oid[] = {1, 3, 6, 1, 4, 1, 62530, 2};
const struct snmp_mib mib_ats2 = {ats2_base_oid, LWIP_ARRAYSIZE(ats2_base_oid), &ats2_root.node};

/*
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LWIP MIB generator - preserved section begin
Code below is preserved on regeneration. Remove these comment lines to regenerate code.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*/

/* --- ats2Measure 62530.2.2 ----------------------------------------------------- */
static s16_t ats2input_scalars_get_value(const struct snmp_scalar_array_node_def *node, void *value)
{
	s16_t value_len;
	zephyr_log("ats2input_scalars_get_value: oid = %d\n", node->oid);

	switch (node->oid) {
	case 1: {
		/* ats2InputDephasing */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	default: {
		LWIP_DEBUGF(SNMP_MIB_DEBUG,
			    ("ats2input_scalars_get_value(): unknown id: %" S32_F "\n", node->oid));
		value_len = 0;
	} break;
	}
	return value_len;
}

static snmp_err_t ats2inputtable_get_instance(const u32_t *column, const u32_t *row_oid,
					      u8_t row_oid_len,
					      struct snmp_node_instance *cell_instance)
{
	/*
	The instance OID of this table consists of following (index) column(s):
	 ats2InputIndex (Integer, OID length = 1)
	*/
	snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

	if (row_oid_len == 1) {
		LWIP_UNUSED_ARG(column);
		LWIP_UNUSED_ARG(row_oid);
		LWIP_UNUSED_ARG(cell_instance);
		/*
		TODO: check if 'row_oid'/'row_oid_len' params contain a valid instance oid for a row
		If so, set 'err = SNMP_ERR_NOERROR;'

		snmp_oid_* methods may be used for easier processing of oid

		In order to avoid decoding OID a second time in subsequent
		get_value/set_test/set_value methods, you may store an arbitrary value (like a
		pointer to target value object) in
		'cell_instance->reference'/'cell_instance->reference_len'. But be aware that not
		always a subsequent method is called -> Do NOT allocate memory here and try to
		release it in subsequent methods!

		You also may replace function pointers in 'cell_instance' param for get/test/set
		methods which contain the default values from table definition, in order to provide
		special methods, for the currently processed cell. Changed pointers are only valid
		for current request.
		*/
	}
	return err;
}
static snmp_err_t ats2inputtable_get_next_instance(const u32_t *column, struct snmp_obj_id *row_oid,
						   struct snmp_node_instance *cell_instance)
{
	/*
	The instance OID of this table consists of following (index) column(s):
	 ats2InputIndex (Integer, OID length = 1)
	*/
	snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

	LWIP_UNUSED_ARG(column);
	LWIP_UNUSED_ARG(row_oid);
	LWIP_UNUSED_ARG(cell_instance);
	/*
	TODO: analyze 'row_oid->id'/'row_oid->len' and return the subsequent row instance
	Be aware that 'row_oid->id'/'row_oid->len' must not point to a valid instance or have
	correct instance length. If 'row_oid->len' is 0, return the first instance. If
	'row_oid->len' is longer than expected, cut superfluous OID parts. If a valid next instance
	is found, store it in 'row_oid->id'/'row_oid->len' and set 'err = SNMP_ERR_NOERROR;'

	snmp_oid_* methods may be used for easier processing of oid

	In order to avoid decoding OID a second time in subsequent get_value/set_test/set_value
	methods, you may store an arbitrary value (like a pointer to target value object) in
	'cell_instance->reference'/'cell_instance->reference_len'. But be aware that not always a
	subsequent method is called -> Do NOT allocate memory here and try to release it in
	subsequent methods!

	You also may replace function pointers in 'cell_instance' param for get/test/set methods
	which contain the default values from table definition, in order to provide special methods,
	for the currently processed cell. Changed pointers are only valid for current request.
	*/
	/*
	For easier processing and getting the next instance, you may use the 'snmp_next_oid_*'
	enumerator. Simply pass all known instance OID's to it and it returns the next valid one:

	struct snmp_next_oid_state state;
	struct snmp_obj_id result_buf;
	snmp_next_oid_init(&state, row_oid->id, row_oid->len, result_buf.id, SNMP_MAX_OBJ_ID_LEN);
	while ({not all instances passed}) {
	  struct snmp_obj_id test_oid;
	  {fill test_oid to create instance oid for next instance}
	  snmp_next_oid_check(&state, test_oid.id, test_oid.len, {target_data_ptr});
	}
	if(state.status == SNMP_NEXT_OID_STATUS_SUCCESS) {
	  snmp_oid_assign(row_oid, state.next_oid, state.next_oid_len);
	  cell_instance->reference.ptr = state.reference; //==target_data_ptr, for usage in
	subsequent get/test/set err = SNMP_ERR_NOERROR;
	}
	*/
	return err;
}
static s16_t ats2inputtable_get_value(struct snmp_node_instance *cell_instance, void *value)
{
	s16_t value_len;

	switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)) {
	case 1: {
		/* ats2InputIndex */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 2: {
		/* ats2InputVoltage */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 3: {
		/* ats2InputFrequency */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	default: {
		LWIP_DEBUGF(SNMP_MIB_DEBUG,
			    ("ats2inputtable_get_value(): unknown id: %" S32_F "\n",
			     SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
		value_len = 0;
	} break;
	}
	return value_len;
}

static s16_t ats2output_scalars_get_value(const struct snmp_scalar_array_node_def *node,
					  void *value)
{
	s16_t value_len;

	zephyr_log("ats2output_scalars_get_value: oid = %d\n", node->oid);
	switch (node->oid) {
	case 1: {
		/* ats2OutputVoltage */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 2: {
		/* ats2OutputCurrent */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	default: {
		LWIP_DEBUGF(
			SNMP_MIB_DEBUG,
			("ats2output_scalars_get_value(): unknown id: %" S32_F "\n", node->oid));
		value_len = 0;
	} break;
	}
	return value_len;
}

static s16_t ats2OperationMode_get_value(struct snmp_node_instance *instance, void *value)
{
	s16_t value_len;
	s32_t *v = (s32_t *)value;

	*v = ask_ats_mode();
	zephyr_log("ats2OperationMode_get_value node %d, return %d\n", instance->node->oid, *v);

	LWIP_UNUSED_ARG(instance);
	/* TODO: put requested value to '*v' here */
	value_len = sizeof(s32_t);
	LWIP_UNUSED_ARG(v);
	return value_len;
}

/* --- ats2Status 62530.2.3 ----------------------------------------------------- */
static s16_t ats2inputstatus_scalars_get_value(const struct snmp_scalar_array_node_def *node,
					       void *value)
{
	s16_t value_len;

	zephyr_log("ats2inputstatus_scalars_get_value: oid = %d\n", node->oid);
	switch (node->oid) {
	case 1: {
		/* ats2InputStatusDephasing */
		s32_t *v = (s32_t *)value;
		*v = 4;
		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	default: {
		LWIP_DEBUGF(SNMP_MIB_DEBUG,
			    ("ats2inputstatus_scalars_get_value(): unknown id: %" S32_F "\n",
			     node->oid));
		value_len = 0;
	} break;
	}
	return value_len;
}

static snmp_err_t ats2inputstatustable_get_instance(const u32_t *column, const u32_t *row_oid,
						    u8_t row_oid_len,
						    struct snmp_node_instance *cell_instance)
{
	/*
	The instance OID of this table consists of following (index) column(s):
	 ats2InputStatusIndex (Integer, OID length = 1)
	*/
	snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

	if (row_oid_len == 1) {
		LWIP_UNUSED_ARG(column);
		LWIP_UNUSED_ARG(row_oid);
		LWIP_UNUSED_ARG(cell_instance);
		/*
		TODO: check if 'row_oid'/'row_oid_len' params contain a valid instance oid for a row
		If so, set 'err = SNMP_ERR_NOERROR;'

		snmp_oid_* methods may be used for easier processing of oid

		In order to avoid decoding OID a second time in subsequent
		get_value/set_test/set_value methods, you may store an arbitrary value (like a
		pointer to target value object) in
		'cell_instance->reference'/'cell_instance->reference_len'. But be aware that not
		always a subsequent method is called -> Do NOT allocate memory here and try to
		release it in subsequent methods!

		You also may replace function pointers in 'cell_instance' param for get/test/set
		methods which contain the default values from table definition, in order to provide
		special methods, for the currently processed cell. Changed pointers are only valid
		for current request.
		*/
	}
	return err;
}
static snmp_err_t ats2inputstatustable_get_next_instance(const u32_t *column,
							 struct snmp_obj_id *row_oid,
							 struct snmp_node_instance *cell_instance)
{
	/*
	The instance OID of this table consists of following (index) column(s):
	 ats2InputStatusIndex (Integer, OID length = 1)
	*/
	snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

	LWIP_UNUSED_ARG(column);
	LWIP_UNUSED_ARG(row_oid);
	LWIP_UNUSED_ARG(cell_instance);
	/*
	TODO: analyze 'row_oid->id'/'row_oid->len' and return the subsequent row instance
	Be aware that 'row_oid->id'/'row_oid->len' must not point to a valid instance or have
	correct instance length. If 'row_oid->len' is 0, return the first instance. If
	'row_oid->len' is longer than expected, cut superfluous OID parts. If a valid next instance
	is found, store it in 'row_oid->id'/'row_oid->len' and set 'err = SNMP_ERR_NOERROR;'

	snmp_oid_* methods may be used for easier processing of oid

	In order to avoid decoding OID a second time in subsequent get_value/set_test/set_value
	methods, you may store an arbitrary value (like a pointer to target value object) in
	'cell_instance->reference'/'cell_instance->reference_len'. But be aware that not always a
	subsequent method is called -> Do NOT allocate memory here and try to release it in
	subsequent methods!

	You also may replace function pointers in 'cell_instance' param for get/test/set methods
	which contain the default values from table definition, in order to provide special methods,
	for the currently processed cell. Changed pointers are only valid for current request.
	*/
	/*
	For easier processing and getting the next instance, you may use the 'snmp_next_oid_*'
	enumerator. Simply pass all known instance OID's to it and it returns the next valid one:

	struct snmp_next_oid_state state;
	struct snmp_obj_id result_buf;
	snmp_next_oid_init(&state, row_oid->id, row_oid->len, result_buf.id, SNMP_MAX_OBJ_ID_LEN);
	while ({not all instances passed}) {
	  struct snmp_obj_id test_oid;
	  {fill test_oid to create instance oid for next instance}
	  snmp_next_oid_check(&state, test_oid.id, test_oid.len, {target_data_ptr});
	}
	if(state.status == SNMP_NEXT_OID_STATUS_SUCCESS) {
	  snmp_oid_assign(row_oid, state.next_oid, state.next_oid_len);
	  cell_instance->reference.ptr = state.reference; //==target_data_ptr, for usage in
	subsequent get/test/set err = SNMP_ERR_NOERROR;
	}
	*/
	return err;
}
static s16_t ats2inputstatustable_get_value(struct snmp_node_instance *cell_instance, void *value)
{
	s16_t value_len;

	switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)) {
	case 1: {
		/* ats2InputStatusIndex */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 2: {
		/* ats2InputStatusFrequency */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 3: {
		/* ats2InputStatusGood */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 4: {
		/* ats2InputStatusInternalFailure */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 5: {
		/* ats2InputStatusVoltage */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 6: {
		/* ats2InputStatusUsed */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	default: {
		LWIP_DEBUGF(SNMP_MIB_DEBUG,
			    ("ats2inputstatustable_get_value(): unknown id: %" S32_F "\n",
			     SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
		value_len = 0;
	} break;
	}
	return value_len;
}

static s16_t ats2outputstatus_scalars_get_value(const struct snmp_scalar_array_node_def *node,
						void *value)
{
	s16_t value_len;

	zephyr_log("ats2outputstatus_scalars_get_value: oid = %d\n", node->oid);
	switch (node->oid) {
	case 1: {
		/* ats2StatusInternalFailure */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 2: {
		/* ats2StatusOutput */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 3: {
		/* ats2StatusOverload */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 4: {
		/* ats2StatusOverTemperature */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 5: {
		/* ats2StatusShortCircuit */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 6: {
		/* ats2StatusCommunicationLost */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 7: {
		/* ats2StatusConfigurationFailure */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	default: {
		LWIP_DEBUGF(SNMP_MIB_DEBUG,
			    ("ats2outputstatus_scalars_get_value(): unknown id: %" S32_F "\n",
			     node->oid));
		value_len = 0;
	} break;
	}
	return value_len;
}

/* --- ats2Config 62530.2.4 ----------------------------------------------------- */
static s16_t ats2configtime_scalars_get_value(const struct snmp_scalar_array_node_def *node,
					      void *value)
{
	s16_t value_len;

	zephyr_log("ats2configtime_scalars_get_value: oid = %d\n", node->oid);
	switch (node->oid) {
	case 1: {
		/* ats2ConfigTimeRTC */
		u32_t *v = (u32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(u32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	default: {
		LWIP_DEBUGF(SNMP_MIB_DEBUG,
			    ("ats2configtime_scalars_get_value(): unknown id: %" S32_F "\n",
			     node->oid));
		value_len = 0;
	} break;
	}
	return value_len;
}
static snmp_err_t ats2configtime_scalars_set_test(const struct snmp_scalar_array_node_def *node,
						  u16_t len, void *value)
{
	snmp_err_t err = SNMP_ERR_WRONGVALUE;

	LWIP_UNUSED_ARG(value);
	LWIP_UNUSED_ARG(len);

	zephyr_log("ats2configtime_scalars_set_test: oid = %d\n", node->oid);
	switch (node->oid) {
	case 1: {
		/* ats2ConfigTimeRTC */

		err = SNMP_ERR_NOERROR;
	} break;
	default: {
		LWIP_DEBUGF(
			SNMP_MIB_DEBUG,
			("ats2configtime_scalars_set_test(): unknown id: %" S32_F "\n", node->oid));
	} break;
	}
	return err;
}
static snmp_err_t ats2configtime_scalars_set_value(const struct snmp_scalar_array_node_def *node,
						   u16_t len, void *value)
{
	snmp_err_t err = SNMP_ERR_NOERROR;

	LWIP_UNUSED_ARG(len);

	zephyr_log("ats2configtime set value: oid = %d\n", node->oid);
	switch (node->oid) {
	case 1: {
		/* ats2ConfigTimeRTC */
		u32_t *v = (u32_t *)value;

		/* TODO: store new value contained in '*v' here */
		LWIP_UNUSED_ARG(v);
	} break;
	default: {
		LWIP_DEBUGF(SNMP_MIB_DEBUG,
			    ("ats2configtime_scalars_set_value(): unknown id: %" S32_F "\n",
			     node->oid));
	} break;
	}
	return err;
}

static s16_t ats2config_treenode_get_value(struct snmp_node_instance *instance, void *value)
{
	s16_t value_len;

	zephyr_log("ats2config_treenode_get_value: oid = %d\n", instance->node->oid);
	switch (instance->node->oid) {
	case 2: {
		/* ats2ConfigInputVoltageRating */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 3: {
		/* ats2ConfigInputFrequencyRating */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 4: {
		/* ats2ConfigOutputVoltage */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 5: {
		/* ats2ConfigPreferred */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 6: {
		/* ats2ConfigSensitivity */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 7: {
		/* ats2ConfigTransferMode */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 8: {
		/* ats2ConfigTransferTest */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 9: {
		/* ats2ConfigBrownoutLow */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 10: {
		/* ats2ConfigBrownoutLowDerated */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 11: {
		/* ats2ConfigBrownoutHigh */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 12: {
		/* ats2ConfigHysteresisVoltage */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	default: {
		LWIP_DEBUGF(SNMP_MIB_DEBUG,
			    ("ats2config_treenode_get_value(): unknown id: %" S32_F "\n",
			     instance->node->oid));
		value_len = 0;
	} break;
	}
	return value_len;
}
static snmp_err_t ats2config_treenode_set_test(struct snmp_node_instance *instance, u16_t len,
					       void *value)
{
	snmp_err_t err = SNMP_ERR_WRONGVALUE;

	switch (instance->node->oid) {
	case 4: {
		/* ats2ConfigOutputVoltage */

		err = SNMP_ERR_NOERROR;
	} break;
	case 5: {
		/* ats2ConfigPreferred */
		s32_t *v = (s32_t *)value;

		LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
		if (((*v >= 1) && (*v <= 2))) {
			err = SNMP_ERR_NOERROR;
		}
	} break;
	case 6: {
		/* ats2ConfigSensitivity */
		s32_t *v = (s32_t *)value;

		LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
		if (((*v >= 1) && (*v <= 3))) {
			err = SNMP_ERR_NOERROR;
		}
	} break;
	case 7: {
		/* ats2ConfigTransferMode */
		s32_t *v = (s32_t *)value;

		LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
		if (((*v >= 1) && (*v <= 2))) {
			err = SNMP_ERR_NOERROR;
		}
	} break;
	default: {
		LWIP_DEBUGF(SNMP_MIB_DEBUG,
			    ("ats2config_treenode_set_test(): unknown id: %" S32_F "\n",
			     instance->node->oid));
	} break;
	}
	return err;
}
static snmp_err_t ats2config_treenode_set_value(struct snmp_node_instance *instance, u16_t len,
						void *value)
{
	snmp_err_t err = SNMP_ERR_NOERROR;

	LWIP_UNUSED_ARG(len);
	switch (instance->node->oid) {
	case 4: {
		/* ats2ConfigOutputVoltage */
		s32_t *v = (s32_t *)value;

		/* TODO: store new value contained in '*v' here */
		LWIP_UNUSED_ARG(v);
	} break;
	case 5: {
		/* ats2ConfigPreferred */
		s32_t *v = (s32_t *)value;

		/* TODO: store new value contained in '*v' here */
		LWIP_UNUSED_ARG(v);
	} break;
	case 6: {
		/* ats2ConfigSensitivity */
		s32_t *v = (s32_t *)value;

		/* TODO: store new value contained in '*v' here */
		LWIP_UNUSED_ARG(v);
	} break;
	case 7: {
		/* ats2ConfigTransferMode */
		s32_t *v = (s32_t *)value;

		/* TODO: store new value contained in '*v' here */
		LWIP_UNUSED_ARG(v);
	} break;
	default: {
		LWIP_DEBUGF(SNMP_MIB_DEBUG,
			    ("ats2config_treenode_set_value(): unknown id: %" S32_F "\n",
			     instance->node->oid));
	} break;
	}
	return err;
}

/* --- ats2Environment 62530.2.5 ----------------------------------------------------- */
static snmp_err_t ats2contactsensetable_get_instance(const u32_t *column, const u32_t *row_oid,
						     u8_t row_oid_len,
						     struct snmp_node_instance *cell_instance)
{
	/*
	The instance OID of this table consists of following (index) column(s):
	 ats2ContactIndex (Integer, OID length = 1)
	*/
	snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

	if (row_oid_len == 1) {
		LWIP_UNUSED_ARG(column);
		LWIP_UNUSED_ARG(row_oid);
		LWIP_UNUSED_ARG(cell_instance);
		/*
		TODO: check if 'row_oid'/'row_oid_len' params contain a valid instance oid for a row
		If so, set 'err = SNMP_ERR_NOERROR;'

		snmp_oid_* methods may be used for easier processing of oid

		In order to avoid decoding OID a second time in subsequent
		get_value/set_test/set_value methods, you may store an arbitrary value (like a
		pointer to target value object) in
		'cell_instance->reference'/'cell_instance->reference_len'. But be aware that not
		always a subsequent method is called -> Do NOT allocate memory here and try to
		release it in subsequent methods!

		You also may replace function pointers in 'cell_instance' param for get/test/set
		methods which contain the default values from table definition, in order to provide
		special methods, for the currently processed cell. Changed pointers are only valid
		for current request.
		*/
	}
	return err;
}
static snmp_err_t ats2contactsensetable_get_next_instance(const u32_t *column,
							  struct snmp_obj_id *row_oid,
							  struct snmp_node_instance *cell_instance)
{
	/*
	The instance OID of this table consists of following (index) column(s):
	 ats2ContactIndex (Integer, OID length = 1)
	*/
	snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

	LWIP_UNUSED_ARG(column);
	LWIP_UNUSED_ARG(row_oid);
	LWIP_UNUSED_ARG(cell_instance);
	/*
	TODO: analyze 'row_oid->id'/'row_oid->len' and return the subsequent row instance
	Be aware that 'row_oid->id'/'row_oid->len' must not point to a valid instance or have
	correct instance length. If 'row_oid->len' is 0, return the first instance. If
	'row_oid->len' is longer than expected, cut superfluous OID parts. If a valid next instance
	is found, store it in 'row_oid->id'/'row_oid->len' and set 'err = SNMP_ERR_NOERROR;'

	snmp_oid_* methods may be used for easier processing of oid

	In order to avoid decoding OID a second time in subsequent get_value/set_test/set_value
	methods, you may store an arbitrary value (like a pointer to target value object) in
	'cell_instance->reference'/'cell_instance->reference_len'. But be aware that not always a
	subsequent method is called -> Do NOT allocate memory here and try to release it in
	subsequent methods!

	You also may replace function pointers in 'cell_instance' param for get/test/set methods
	which contain the default values from table definition, in order to provide special methods,
	for the currently processed cell. Changed pointers are only valid for current request.
	*/
	/*
	For easier processing and getting the next instance, you may use the 'snmp_next_oid_*'
	enumerator. Simply pass all known instance OID's to it and it returns the next valid one:

	struct snmp_next_oid_state state;
	struct snmp_obj_id result_buf;
	snmp_next_oid_init(&state, row_oid->id, row_oid->len, result_buf.id, SNMP_MAX_OBJ_ID_LEN);
	while ({not all instances passed}) {
	  struct snmp_obj_id test_oid;
	  {fill test_oid to create instance oid for next instance}
	  snmp_next_oid_check(&state, test_oid.id, test_oid.len, {target_data_ptr});
	}
	if(state.status == SNMP_NEXT_OID_STATUS_SUCCESS) {
	  snmp_oid_assign(row_oid, state.next_oid, state.next_oid_len);
	  cell_instance->reference.ptr = state.reference; //==target_data_ptr, for usage in
	subsequent get/test/set err = SNMP_ERR_NOERROR;
	}
	*/
	return err;
}
static s16_t ats2contactsensetable_get_value(struct snmp_node_instance *cell_instance, void *value)
{
	s16_t value_len;

	switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)) {
	case 1: {
		/* ats2ContactIndex */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 2: {
		/* ats2ContactType */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 3: {
		/* ats2ContactState */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	default: {
		LWIP_DEBUGF(SNMP_MIB_DEBUG,
			    ("ats2contactsensetable_get_value(): unknown id: %" S32_F "\n",
			     SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
		value_len = 0;
	} break;
	}
	return value_len;
}
static snmp_err_t ats2contactsensetable_set_test(struct snmp_node_instance *cell_instance,
						 u16_t len, void *value)
{
	snmp_err_t err = SNMP_ERR_WRONGVALUE;

	switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)) {
	case 2: {
		/* ats2ContactType */
		s32_t *v = (s32_t *)value;

		LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
		if (((*v >= 1) && (*v <= 4))) {
			err = SNMP_ERR_NOERROR;
		}
	} break;
	default: {
		LWIP_DEBUGF(SNMP_MIB_DEBUG,
			    ("ats2contactsensetable_set_test(): unknown id: %" S32_F "\n",
			     SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
	} break;
	}
	return err;
}
static snmp_err_t ats2contactsensetable_set_value(struct snmp_node_instance *cell_instance,
						  u16_t len, void *value)
{
	snmp_err_t err = SNMP_ERR_NOERROR;

	LWIP_UNUSED_ARG(len);
	switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)) {
	case 2: {
		/* ats2ContactType */
		s32_t *v = (s32_t *)value;

		/* TODO: store new value contained in '*v' here */
		LWIP_UNUSED_ARG(v);
	} break;
	default: {
		LWIP_DEBUGF(SNMP_MIB_DEBUG,
			    ("ats2contactsensetable_set_value(): unknown id: %" S32_F "\n",
			     SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
	} break;
	}
	return err;
}

static s16_t ats2environment_treenode_get_value(struct snmp_node_instance *instance, void *value)
{
	s16_t value_len;

	switch (instance->node->oid) {
	case 1: {
		/* ats2EnvRemoteTemp */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 2: {
		/* ats2EnvRemoteHumidity */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 3: {
		/* ats2EnvNumContacts */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 5: {
		/* ats2EnvRemoteTempLowerLimit */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 6: {
		/* ats2EnvRemoteTempUpperLimit */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 7: {
		/* ats2EnvRemoteHumidityLowerLimit */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	case 8: {
		/* ats2EnvRemoteHumidityUpperLimit */
		s32_t *v = (s32_t *)value;

		/* TODO: put requested value to '*v' here */
		value_len = sizeof(s32_t);
		LWIP_UNUSED_ARG(v);
	} break;
	default: {
		LWIP_DEBUGF(SNMP_MIB_DEBUG,
			    ("ats2environment_treenode_get_value(): unknown id: %" S32_F "\n",
			     instance->node->oid));
		value_len = 0;
	} break;
	}
	return value_len;
}
static snmp_err_t ats2environment_treenode_set_test(struct snmp_node_instance *instance, u16_t len,
						    void *value)
{
	snmp_err_t err = SNMP_ERR_WRONGVALUE;

	switch (instance->node->oid) {
	case 5: {
		/* ats2EnvRemoteTempLowerLimit */
		s32_t *v = (s32_t *)value;

		LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
		if (((*v >= -100) && (*v <= 200))) {
			err = SNMP_ERR_NOERROR;
		}
	} break;
	case 6: {
		/* ats2EnvRemoteTempUpperLimit */
		s32_t *v = (s32_t *)value;

		LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
		if (((*v >= -100) && (*v <= 200))) {
			err = SNMP_ERR_NOERROR;
		}
	} break;
	case 7: {
		/* ats2EnvRemoteHumidityLowerLimit */
		s32_t *v = (s32_t *)value;

		LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
		if (((*v >= 0) && (*v <= 100))) {
			err = SNMP_ERR_NOERROR;
		}
	} break;
	case 8: {
		/* ats2EnvRemoteHumidityUpperLimit */
		s32_t *v = (s32_t *)value;

		LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
		if (((*v >= 0) && (*v <= 100))) {
			err = SNMP_ERR_NOERROR;
		}
	} break;
	default: {
		LWIP_DEBUGF(SNMP_MIB_DEBUG,
			    ("ats2environment_treenode_set_test(): unknown id: %" S32_F "\n",
			     instance->node->oid));
	} break;
	}
	return err;
}
static snmp_err_t ats2environment_treenode_set_value(struct snmp_node_instance *instance, u16_t len,
						     void *value)
{
	snmp_err_t err = SNMP_ERR_NOERROR;

	LWIP_UNUSED_ARG(len);
	switch (instance->node->oid) {
	case 5: {
		/* ats2EnvRemoteTempLowerLimit */
		s32_t *v = (s32_t *)value;

		/* TODO: store new value contained in '*v' here */
		LWIP_UNUSED_ARG(v);
	} break;
	case 6: {
		/* ats2EnvRemoteTempUpperLimit */
		s32_t *v = (s32_t *)value;

		/* TODO: store new value contained in '*v' here */
		LWIP_UNUSED_ARG(v);
	} break;
	case 7: {
		/* ats2EnvRemoteHumidityLowerLimit */
		s32_t *v = (s32_t *)value;

		/* TODO: store new value contained in '*v' here */
		LWIP_UNUSED_ARG(v);
	} break;
	case 8: {
		/* ats2EnvRemoteHumidityUpperLimit */
		s32_t *v = (s32_t *)value;

		/* TODO: store new value contained in '*v' here */
		LWIP_UNUSED_ARG(v);
	} break;
	default: {
		LWIP_DEBUGF(SNMP_MIB_DEBUG,
			    ("ats2environment_treenode_set_value(): unknown id: %" S32_F "\n",
			     instance->node->oid));
	} break;
	}
	return err;
}

/* --- ats2  ----------------------------------------------------- */
#endif /* LWIP_SNMP */
